# Forward all logs to central loghost using RELP

# run as root to be able to read files owned by nw2 and create file under workdir
$PrivDropToUser root

# We will read all log files from file system
# Load Text File Input Module
module(load="imfile" timeoutGranularity="1")
# To use RELP we have to load module first.
# http://www.rsyslog.com/doc/relp.html
module(load="omrelp")

# template for transferring logs over network. We want to forward messages with
# tags longer than 32 symbols, because we have long meaningful log names. 
# We want to forward precise timestamp with timezone.
template (
  name="LongTagForwardFormat"
  type="string"
  string="<%PRI%>%TIMESTAMP:::date-rfc3339% %HOSTNAME% %syslogtag%/%HOSTNAME%/%$.suffix%%msg:::sp-if-no-1st-sp%%msg%"
)

# RuleSet to use for network message forwarding.
ruleset(name="sendToLogserver") {
    action(
      type="omrelp"
      Target="loghost"
      Port="20514"
      Template="LongTagForwardFormat"
      # Queue: http://www.rsyslog.com/doc/v8-stable/concepts/queues.html#disk-assisted-memory-queues
      # Disk-Assisted Memory Queue: queue.type="LinkedList" + queue.filename
      queue.type="LinkedList"
      queue.filename="q_sendToLogserver"
      # queue.size - max elements in memory
      queue.size="10000"
      # queue.highwatermark - when to start saving to disk
      queue.highwatermark="9000"
      # queue.lowwatermark - when to stop saving to disk
      queue.lowwatermark="50"
      queue.maxdiskspace="500m"
      # queue.saveonshutdown - save on disk between rsyslog shutdown
      queue.saveonshutdown="on"
      # action.resumeRetryCount - number of retries for action, -1 = eternal
      action.resumeRetryCount="-1"
      action.reportSuspension="on"
      action.reportSuspensionContinuation="on"
      # action.resumeInterval - interval to suspend action if destination can not be connected
      # After each 10 retries, the interval is extended: (numRetries / 10 + 1) * Action.ResumeInterval
      action.resumeInterval="10"
    )
    # action(type="omfwd" Target="loghost" Port="514" Template="LongTagForwardFormat")
}

# create Input reading log files, and assign it our RuleSet
input(
  type="imfile"
  File="/var/log/nsg/*"
  Facility="local2"
  # Multi-line detection: messages is terminated when the next one begins with any alphanumeric char
  startmsg.regex="^[0-9A-Za-z]"
  # terminate multi-line if no input received after 2s. This will send last line
  readTimeout="1"
  # no need to escape new line for RELP
  escapeLF="off"
  # assign tag
  Tag="nsg"
  # pass to parsing ruleset
  Ruleset="nsg_logs"
  # pass filename in message metadata
  addMetadata="on"
  # disable state files and skip to end of log to work around the bug:
  # multiline timeout did not work if state file exists
  # See https://github.com/rsyslog/rsyslog/issues/1445
  # this was later fixed in v8.28.0
  # Once we upgrade to Ubuntu image with newer rsyslog we can enable it again
  #PersistStateInterval="5"
  #stateFile=""
  # seek to end of file on rsyslog start to avoid sending old lines since we donts use statefile
  freshStartTail="on"
)

# we need this to extract log file name from full path and save it in local var $.suffix
# then we can call ruleset sendToLogserver
ruleset(name="nsg_logs") {
  # http://www.rsyslog.com/doc/v8-stable/rainerscript/functions.html
  # re_extract(expr, re, match, submatch, no-found)
  set $.suffix=re_extract($!metadata!filename, "(.*)/([^/]*)", 0, 2, "all.log"); 
  call sendToLogserver
}
